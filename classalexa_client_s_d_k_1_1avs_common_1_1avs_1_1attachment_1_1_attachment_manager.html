<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AlexaClientSDK: alexaClientSDK::avsCommon::avs::attachment::AttachmentManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="avs-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlexaClientSDK
   &#160;<span id="projectnumber">1.9.0</span>
   </div>
   <div id="projectbrief">A cross-platform, modular SDK for interacting with the Alexa Voice Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacealexa_client_s_d_k.html">alexaClientSDK</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common.html">avsCommon</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1avs.html">avs</a></li><li class="navelem"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment.html">attachment</a></li><li class="navelem"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html">AttachmentManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">alexaClientSDK::avsCommon::avs::attachment::AttachmentManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_attachment_manager_8h_source.html">AttachmentManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for alexaClientSDK::avsCommon::avs::attachment::AttachmentManager:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager__inherit__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_inherit__map" alt="Inheritance graph"/></div>
<map name="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_inherit__map" id="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for alexaClientSDK::avsCommon::avs::attachment::AttachmentManager:</div>
<div class="dyncontent">
<div class="center"><img src="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager__coll__graph.png" border="0" usemap="#alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_coll__map" alt="Collaboration graph"/></div>
<map name="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_coll__map" id="alexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a008551364c461b579379796935f2e66e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a008551364c461b579379796935f2e66e">AttachmentType</a> { <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a008551364c461b579379796935f2e66ea1b43a7a738923b3e20abbe1f698d176b">AttachmentType::IN_PROCESS</a>
 }</td></tr>
<tr class="separator:a008551364c461b579379796935f2e66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68bf040957b50b55926e90d4fc445355"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a68bf040957b50b55926e90d4fc445355">AttachmentManager</a> (<a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a008551364c461b579379796935f2e66e">AttachmentType</a> attachmentType)</td></tr>
<tr class="separator:a68bf040957b50b55926e90d4fc445355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56509513f1e7062aa5d68de1ce11f0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#ade56509513f1e7062aa5d68de1ce11f0">generateAttachmentId</a> (const std::string &amp;contextId, const std::string &amp;contentId) const override</td></tr>
<tr class="separator:ade56509513f1e7062aa5d68de1ce11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56711ae0ca08a8fc8bf242d1149439e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#ac56711ae0ca08a8fc8bf242d1149439e">setAttachmentTimeoutMinutes</a> (std::chrono::minutes timeoutMinutes) override</td></tr>
<tr class="separator:ac56711ae0ca08a8fc8bf242d1149439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d75cb4670ed6172e9c8cd38f630a900"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a5d75cb4670ed6172e9c8cd38f630a900">createWriter</a> (const std::string &amp;attachmentId, <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a7b17d768f16a6f5da766df780d94bbd5">utils::sds::WriterPolicy</a> policy=<a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a7b17d768f16a6f5da766df780d94bbd5a5d027622828a53a8fc66dd131952c8a1">avsCommon::utils::sds::WriterPolicy::ALL_OR_NOTHING</a>) override</td></tr>
<tr class="separator:a5d75cb4670ed6172e9c8cd38f630a900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36725b6e72363308855f792608564d58"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a36725b6e72363308855f792608564d58">createReader</a> (const std::string &amp;attachmentId, <a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">utils::sds::ReaderPolicy</a> policy) override</td></tr>
<tr class="separator:a36725b6e72363308855f792608564d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html">alexaClientSDK::avsCommon::avs::attachment::AttachmentManagerInterface</a></td></tr>
<tr class="memitem:ac481f7ccf8bc8ef4dfc7e77d8b62af79 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html#ac481f7ccf8bc8ef4dfc7e77d8b62af79">~AttachmentManagerInterface</a> ()=default</td></tr>
<tr class="separator:ac481f7ccf8bc8ef4dfc7e77d8b62af79 inherit pub_methods_classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3beb279fd85d9e6c3142344b6bd16a8d"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::minutes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a3beb279fd85d9e6c3142344b6bd16a8d">ATTACHMENT_MANAGER_TIMOUT_MINUTES_DEFAULT</a> = std::chrono::hours(12)</td></tr>
<tr class="separator:a3beb279fd85d9e6c3142344b6bd16a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805f18281d78596131757329e146fedc"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::minutes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a805f18281d78596131757329e146fedc">ATTACHMENT_MANAGER_TIMOUT_MINUTES_MINIMUM</a> = std::chrono::minutes(1)</td></tr>
<tr class="separator:a805f18281d78596131757329e146fedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows the decoupling of attachment readers and writers from the management of attachments.</p>
<p>This class is thread safe.</p>
<p>A design principle of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a></code> class is that each attachment will have at most one reader and writer.</p>
<p>Application code may query the manager for a reader and writer object at any time, and in any order.</p>
<dl class="section note"><dt>Note</dt><dd>Resource management is currently implemented by a timeout approach. This does have the following limitations:</dd></dl>
<ul>
<li>An <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a> or <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a> has reference to a shared buffer resource for the actual data. This buffer will remain in existence until both the Reader and Writer have been destroyed. </li>
<li>Therefore, application code should ensure that Readers and Writers are destroyed when no longer needed. </li>
<li>The <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html">AttachmentManager</a> will always satisfy a request to create a Reader or Writer - it will not currently enforce a maximum resource limit. </li>
<li>ACSDK-254 will address this by enforcing such limits. It should also be noted however, that a well behaving application may not observe much difference - the future implementation will forcibly close the oldest <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a> to make space for the new one. For a system reading and writing a small set of attachments at any given time, the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html">AttachmentManager</a> should not need to step in and take such action. </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a008551364c461b579379796935f2e66e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a008551364c461b579379796935f2e66e">alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::AttachmentType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A local enumeration allowing the createReader call to act as a factory function for the underlying attachments. This enumeration need not include all specializations of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a></code> class, only the ones that make sense for the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html">AttachmentManager</a></code> to manage. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a008551364c461b579379796935f2e66ea1b43a7a738923b3e20abbe1f698d176b"></a>IN_PROCESS&#160;</td><td class="fielddoc">
<p>This value corresponds to the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_in_process_attachment.html">InProcessAttachment</a></code> class. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a68bf040957b50b55926e90d4fc445355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::AttachmentManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#a008551364c461b579379796935f2e66e">AttachmentType</a>&#160;</td>
          <td class="paramname"><em>attachmentType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentType</td><td>The type of attachments which will be managed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a36725b6e72363308855f792608564d58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a> &gt; alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::createReader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attachmentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a07d2a9441f40d089a1f9a0d7e2baab4b">utils::sds::ReaderPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to an <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a></code>. </p><dl class="section note"><dt>Note</dt><dd>Calls to <code>createReader</code> and <code>createWriter</code> may occur in any order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentId</td><td>The id of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a></code>. </td></tr>
    <tr><td class="paramname">policy</td><td>The <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a></code> policy, which determines the semantics of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html#a4cbeab24735c515366f5c3df77af15e9">AttachmentReader.read()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_reader.html">AttachmentReader</a></code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html#acb07ab71933a232425dc3f5c5fca4625">alexaClientSDK::avsCommon::avs::attachment::AttachmentManagerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a5d75cb4670ed6172e9c8cd38f630a900"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a> &gt; alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::createWriter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attachmentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a7b17d768f16a6f5da766df780d94bbd5">utils::sds::WriterPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="namespacealexa_client_s_d_k_1_1avs_common_1_1utils_1_1sds.html#a7b17d768f16a6f5da766df780d94bbd5a5d027622828a53a8fc66dd131952c8a1">avsCommon::utils::sds::WriterPolicy::ALL_OR_NOTHING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to an <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a></code>. </p><dl class="section note"><dt>Note</dt><dd>Calls to <code>createReader</code> and <code>createWriter</code> may occur in any order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentId</td><td>The id of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a></code>. </td></tr>
    <tr><td class="paramname">policy</td><td>The WriterPolicy that the <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a> should adhere to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_writer.html">AttachmentWriter</a></code>. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html#a14d4e68c212f1edec4c3051b3f321bd6">alexaClientSDK::avsCommon::avs::attachment::AttachmentManagerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ade56509513f1e7062aa5d68de1ce11f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::generateAttachmentId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contextId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contentId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an attachmentId given two particular <code>strings</code> - the contextId and the contentId. Generally, contextId allows disambiguation when two attachment contentIds are not guaranteed to be unique. This function provides a consistent way for different parts of application code to combine contextId and contentId into a single string. Clearly, both the reader and writer of a given attachment need to call this function with the same two strings.</p>
<p>As an example of usage, if an application has several sources of attachments, for example two audio providers, then one pair of contextId / contentId strings might be: { "AudioProvider1", "Attachment1" }. If the other audio provider creates an attachment, then the pair: { "AudioProvider2", "Attachment1" } allows the contextId to disambiguate what happens to be identical contentIds.</p>
<p>If this function is called with one or both strings being empty, then the combine will not be performed. In the case of both strings being empty, an empty string will be returned. If only one string is non-empty, then that string will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextId</td><td>The contextId, which generally reflects the source of the <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a></code>. </td></tr>
    <tr><td class="paramname">contentId</td><td>The contentId, which is considered unique when paired with a particular contextId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined strings, which may be then used as a single attachmentId, per the logic outlined above. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html#a09631169c52ce59e38c4c53a42e76463">alexaClientSDK::avsCommon::avs::attachment::AttachmentManagerInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ac56711ae0ca08a8fc8bf242d1149439e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::setAttachmentTimeoutMinutes </td>
          <td>(</td>
          <td class="paramtype">std::chrono::minutes&#160;</td>
          <td class="paramname"><em>timeoutMinutes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the timeout parameter which is used to ensure unused attachments are eventually cleaned up. This time is specified in minutes. An unused attachment is defined as an attachment for which only a reader or writer was created. Such an <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment.html">Attachment</a> is waiting to be either produced or consumed.</p>
<p>If this function is not called, then the timeout is set to a default value specified by the implementation.</p>
<p>The timeout cannot be set lower than an implementation specific minimum, since too low a timeout could cause attachments to be removed before both reader and writer have had time to request it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutMinutes</td><td>The timeout, expressed in minutes. If this is less than the minimum, then the setting will not be updated, and the function will return false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the timeout was set ok. </dd></dl>

<p>Implements <a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager_interface.html#a66adbefb136ac1d9461ab2aa3945b84e">alexaClientSDK::avsCommon::avs::attachment::AttachmentManagerInterface</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3beb279fd85d9e6c3142344b6bd16a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::chrono::minutes alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::ATTACHMENT_MANAGER_TIMOUT_MINUTES_DEFAULT = std::chrono::hours(12)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the default timeout value for attachments. Any attachment which is inspected in the <code>removeExpiredAttachmentsLocked()</code> call, and whose lifetime exceeds this value, will be released. </p>

</div>
</div>
<a class="anchor" id="a805f18281d78596131757329e146fedc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::chrono::minutes alexaClientSDK::avsCommon::avs::attachment::AttachmentManager::ATTACHMENT_MANAGER_TIMOUT_MINUTES_MINIMUM = std::chrono::minutes(1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the minimum timeout value for attachments. <code><a class="el" href="classalexa_client_s_d_k_1_1avs_common_1_1avs_1_1attachment_1_1_attachment_manager.html#ac56711ae0ca08a8fc8bf242d1149439e">setAttachmentTimeoutMinutes()</a></code> will not accept a value lower than this. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/workplace/avs-device-sdk/AVSCommon/AVS/include/AVSCommon/AVS/Attachment/<a class="el" href="_attachment_manager_8h_source.html">AttachmentManager.h</a></li>
<li>/workplace/avs-device-sdk/AVSCommon/AVS/src/Attachment/<a class="el" href="_attachment_manager_8cpp.html">AttachmentManager.cpp</a></li>
</ul>
</div><!-- contents -->
<html>
  <body>
    <p style="text-align:left;">
      AlexaClientSDK 1.9.0 - Copyright 2016-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
      <span style="float:right;">
	Licensed under the <a HREF=http://aws.amazon.com/apache2.0/>Apache License, Version 2.0</a>
      </span>
    </p>
  </body>
</html>
